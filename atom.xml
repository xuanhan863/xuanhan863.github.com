<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[huoxu.me]]></title>
  <link href="http://xuanhan863.github.com/atom.xml" rel="self"/>
  <link href="http://xuanhan863.github.com/"/>
  <updated>2012-09-03T20:53:29+08:00</updated>
  <id>http://xuanhan863.github.com/</id>
  <author>
    <name><![CDATA[Tony.lee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[架构学习: Reddit 的数据库只有两个表]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/09/03/reddits-database-has-two-tables/"/>
    <updated>2012-09-03T16:10:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/09/03/reddits-database-has-two-tables</id>
    <content type="html"><![CDATA[<p>最近,<a href="http://www.reddit.com/r/IAmA/comments/z1c9z/i_am_barack_obama_president_of_the_united_states/">Obama现身Reddit</a>, 让这个一向以死忠Geek横行的小众技术社区又火了起来.</p>

<p>回顾Reddit 的架构史, 2010 年时, 该创始人Steve Huffman 在<a href="http://highscalability.com/blog/2010/5/17/7-lessons-learned-while-building-reddit-to-270-million-page.       html">High Scalability post from 2010</a> share 过一个ppt, 16页slides大致能一窥究竟.</p>

<blockquote><p>题外话,很好奇Reddit 在<a
href="http://www.rabbitmq.com/">RabbitMQ</a>使用方面有什么技巧?
至少在<a
href="http://www.douban.com">豆瓣</a>
RabbitMQ 貌似不太可控,一动不动就把整个机器的内存都吞光了.</p></blockquote>

<p> <strong>总结的经验是: 开放 Schema,架构不要被模式化.</strong></p>

<p><strong>同时也惊讶的得知他们的数据库中只有两个表</strong>.</p>

<p>Reddit 当时花了很多时间和精力,试图保持数据库(<a href="http://www.postgresql.org">PostgreSQL</a>)的规范化和有条不紊.但当你打算新添加一列到千万量级的数据表时,数据库的行级锁会导致长时间的挂起, not work. 当然, 你也可以维护一个Master/Slave的结构, 进行热备或复制切换,但这无疑增加了运维的复杂度.</p>

<p>重新梳理问题. 不难发现, 在Reddit中, 一切都可以称之为一个Thing: 包括用户,链接,回复,subreddits等. Thing 有着共同的属性, 比如up/down的投票,类型和创建日期. 由Thing再衍生一个Data table. Data table有三列: 对应Thing的ID,键和值, 类json的数据格式( 和豆瓣的使用方法doml基本相近). 这样, 数据库的维护就变的简单,容易了.. 当增加新功能时, 只需要维护相应的Key/Value.</p>

<p>这样做的代价就是你没法使用关系型数据库的features. 没法进行表之间的join, 而且需要你自己维护一致性的问题. 但没有join, 也意味着简单使用一致性hash 就可以做到数据的散列分布, 数据表的切割也变的容易.</p>

<p>这类似于<a href="http://www.mongodb.org">MongoDB</a>, <a href="http://redis.io">Redis</a> 之类的 K/V型db. 它让你在存储数据时不必再考虑模式或索引的问题, 很容易地添加更多的类型到现有对象,更新或横向切分. 同时兼顾高性能 O(1).</p>

<p>从 Hacker News 的<a href="http://news.ycombinator.com/item?id=4468265">这个post</a> 看起来,他们为每个subreddit使用单独的数据库, 当然了, 还是&lt;Thing, Data>..</p>

<p>可以自由转载,但请注明出处</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[致在天堂的奶奶]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/08/31/zhi-zai-tian-tang-de-nai-nai/"/>
    <updated>2012-08-31T18:03:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/08/31/zhi-zai-tian-tang-de-nai-nai</id>
    <content type="html"><![CDATA[<p><strong>今天是农历七月十五(中元节), 今年2月26号, 晚9:27分, 奶奶因病挥别.
到今天为止已是187天. </strong></p>

<p><strong>奶奶, 您在天堂那边还好么? 天堂那边真有那么好? 好到逝去的人, 一个个都不愿意回来</strong></p>

<p>从小都在奶奶身边, 那种被矫宠的依赖伴随着我长大..
奶奶生前最疼我了, 什么都喜欢留给我, 那种毫不掩饰的偏心, 每个人都看在眼里.</p>

<p>奶奶的离去, 可能是我生命中的一块阴影. 每次想到回家后, 将不再能享受到她给我亲手做的可口饭菜, 和近乎无微不至的照顾关爱, 我就眼泪直流.</p>

<p><strong>记忆是一种负担, 它让我陷入无止境的回忆之中, 痛不欲生, 不能自拔.</strong></p>

<p><strong>有些人永远不会忘, 因为舍不得.</strong></p>

<p><strong>我将永远铭记着您从前对我的关爱, 若有来生, 还将重逢.</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Python 中跟踪嵌套函数调用]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/08/31/tracing-nested-function-call-in-python/"/>
    <updated>2012-08-31T15:21:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/08/31/tracing-nested-function-call-in-python</id>
    <content type="html"><![CDATA[<p>有时,当执行复杂的函数调用时,特别是那些涉及到递归算法的函数,很希望能跟踪到它的函数调用堆栈,能跟踪到在执行过程中实际使用了哪些参数和返回值, 但又不想使用诸如pdb之类的debug工具.</p>

<p>下面是一个简单的Python decorator（适用于2.7和3.2 +）</p>

<pre><code>import sys
from functools import wraps

class TraceCalls(object):
    """ 
        使用这个decorator 可以追踪到函数递归调用的深度.
    """
    def __init__(self, stream=sys.stdout, indent_step=2, show_ret=False):
        self.stream = stream
        self.indent_step = indent_step
        self.show_ret = show_ret

        # This is a class attribute since we want to share the indentation
        # level between different traced functions, in case they call
        # each other.
        TraceCalls.cur_indent = 0

    def __call__(self, fn):
        @wraps(fn)
        def wrapper(*args, **kwargs):
            indent = ' ' * TraceCalls.cur_indent
            argstr = ', '.join(
                [repr(a) for a in args] +
                ["%s=%s" % (a, repr(b)) for a, b in kwargs.items()])
            self.stream.write('%s%s(%s)\n' % (indent, fn.__name__, argstr))

            TraceCalls.cur_indent += self.indent_step
            ret = fn(*args, **kwargs)
            TraceCalls.cur_indent -= self.indent_step

            if self.show_ret:
                self.stream.write('%s--&gt; %s\n' % (indent, ret))
            return ret
        return wrapper
</code></pre>

<p>我们可以这样用它:</p>

<pre><code>@TraceCalls()
def iseven(n):
    return True if n == 0 else isodd(n - 1)

@TraceCalls()
def isodd(n):
    return False if n == 0 else iseven(n - 1)

print(iseven(7))
</code></pre>

<p>输出它的函数堆栈调用层级:</p>

<pre><code>iseven(7)
  isodd(6)
    iseven(5)
      isodd(4)
        iseven(3)
          isodd(2)
            iseven(1)
              isodd(0)
False
</code></pre>

<p>这个decorator tracer 还有几个有用的参数:</p>

<pre><code>stream: 打印跟踪输出,默认情况下输出到到sys.stdout.
indent_step: 定义每个嵌套调用,有多少个空间字符的缩进.
show_ret: 设置为true时,显示每个调用的返回值.



@TraceCalls(indent_step=4, show_ret=True)
def flatten(lst):
    if isinstance(lst, list):
        return sum((flatten(item) for item in lst), [])
    else:
        return [lst]

list(flatten([1, 2, [3, [4, 5], 6, [7, [9], 12]], 4, [6, 9]]))
</code></pre>

<p>调整后的输出:</p>

<pre><code>flatten([1, 2, [3, [4, 5], 6, [7, [9], 12]], 4, [6, 9]])
    flatten(1)
    --&gt; [1]
    flatten(2)
    --&gt; [2]
    flatten([3, [4, 5], 6, [7, [9], 12]])
        flatten(3)
        --&gt; [3]
        flatten([4, 5])
            flatten(4)
            --&gt; [4]
            flatten(5)
            --&gt; [5]
        --&gt; [4, 5]
        flatten(6)
        --&gt; [6]
        flatten([7, [9], 12])
            flatten(7)
            --&gt; [7]
            flatten([9])
                flatten(9)
                --&gt; [9]
            --&gt; [9]
            flatten(12)
            --&gt; [12]
        --&gt; [7, 9, 12]
    --&gt; [3, 4, 5, 6, 7, 9, 12]
    flatten(4)
    --&gt; [4]
    flatten([6, 9])
        flatten(6)
        --&gt; [6]
        flatten(9)
        --&gt; [9]
    --&gt; [6, 9]
--&gt; [1, 2, 3, 4, 5, 6, 7, 9, 12, 4, 6, 9]
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[a git launcher]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/08/31/a-git-launcher/"/>
    <updated>2012-08-31T12:26:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/08/31/a-git-launcher</id>
    <content type="html"><![CDATA[<p>a git launcher : )</p>

<p>当你输错后, 有一个ASCII码的terminal动画效果. 之后, 它会把你的意思正确执行.</p>

<p><img src="http://r-wos.org/media/gti-animation"></img></p>

<p>只有一个C 文件的实现, 只针对git命令.</p>

<pre><code>$ git clone https://github.com/rwos/gti.git
$ make
$ make install # as root, probably
</code></pre>

<p><strong>参考: <a href="http://r-wos.org/hacks/gti">http://r-wos.org/hacks/gti</a></strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个通用的C++ 单例模型 ]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/08/30/a-generic-singleton/"/>
    <updated>2012-08-30T17:29:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/08/30/a-generic-singleton</id>
    <content type="html"><![CDATA[<p>昨天,我发现一个问题,这是一年前未能解决的方案.这个问题很简单:创建一个通用的单例对象模型.对单例模型的定义是: &#8220;确保一个类只有一个实例,并提供一个全局访问点&#8221;.</p>

<p>常见的版本是使用模板模式（CRTP）.先介绍CRTP,这个概念很简单,只是继承了一个模板基类,它允许创建静态多态性或者实例计数器&#8230; 可以参考维基百科对此的定义 <a href="http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">Curiously recurring template pattern</a></p>

<p>使用CRTP的方式, 每次程序结束时, 我都需要显示调用一次 destroySingleton.
所以,我必须设计一个通用的解决方案,围绕整个对象生命周期, 从对象构造到它调用结束被析构.</p>

<p>最初,我使用两个阶级,两个构造函数,我虽然打的事实,不使用模板函数的实例,可以容忍不正确（没有类型检查，没有名字结合&#8230;这必须是有效的语法）。下面是一个例子：</p>

<pre><code>#include &lt;string&gt;

template &lt;class T&gt;
class Singleton
{
public:
  static T* get_instance(int v)
  {
    if (!instance_)
      instance_ = new T(v);

    return instance_;
  }

  static T* get_instance(std::string s)
  {
    if (!instance_)
      instance_ = new T(s);

    return instance_;
  } // Sounds familiar...

  static void destroy_instance()
  {
    delete instance_;
    instance_ = nullptr;
  }

private:
  static T* instance_;
};

template &lt;class T&gt; T* Singleton&lt;T&gt;::instance_ = nullptr;

// The classes that will be singletons:

class Single: public Singleton&lt;Single&gt;
{
public:
  Single(std::string s): s_(s) {}

private:
  std::string s_;
};

class Map: public Singleton&lt;Map&gt;
{
public:
  Map(int scale): scale_(scale) {}

private:
  int scale_;
};

// How to create and destroy them:

int main()
{
  Single* s = Single::get_instance("Forever Alone");
  Map* m = Map::get_instance(42);

  // Use these singletons.

  Map::destroy_instance();
  Single::destroy_instance();
}
</code></pre>

<p>这个版本实现了通用单例的一半,它完全非侵入式的转化为单例类.</p>

<p>事实上,必须建立两个GET_INSTANCE,因为它有两个不同的构造函数.由于可能对象构造函数的参数组合的数量是无限的,所以这个解决方案并不好.</p>

<p>昨天,研究了一下<a href="http://enki-tech.blogspot.fr/2012/08/c11-vector-improved-how-it-works.html"> C++ 11</a>机制, 发现它允许创建emplace_back. 其实,我们只需要创建一个GET_INSTANCE,作为参数传给构造函数.不重复,完全通用的,这就是我想要的.
下面是Singleton类的最终版本:</p>

<pre><code>#include &lt;iostream&gt;

template &lt;class T&gt;
class Singleton
{
public:
  template &lt;typename... Args&gt;
  static
  T* get_instance(Args... args)
  {
    if (!instance_)
      {
        instance_ = new T(std::forward&lt;Args&gt;(args)...);
      }

    return instance_;
  }

  static
  void destroy_instance()
  {
    delete instance_;
    instance_ = nullptr;
  }

private:
  static T* instance_;
};

template &lt;class T&gt; T*  Singleton&lt;T&gt;::instance_ = nullptr;

class Map: public Singleton&lt;Map&gt;
{
  friend class Singleton&lt;Map&gt;;
private:
  Map(int size_x, int size_y): size_x_{size_x}, size_y_{size_y} {}

public:
  int size_x_;
  int size_y_;
};

int main()
{
  Map* m = Map::get_instance(4, 5);

  std::cout &lt;&lt; m-&gt;size_y_ &lt;&lt; std::endl; // Outputs 5.

  Map::destroy_instance();
}
</code></pre>

<p>简单翻译, 原文出处: <a href="http://enki-tech.blogspot.fr/2012/08/c11-generic-singleton.html">C++11: A generic Singleton</a>
自备翻墙.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用GnuPG 对文件进行对称加密]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/08/28/simple-password-encrypted-files-w-slash-gnupg/"/>
    <updated>2012-08-28T13:45:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/08/28/simple-password-encrypted-files-w-slash-gnupg</id>
    <content type="html"><![CDATA[<p>在互联网上发送或共享一些文件文档,我可能希望它是安全的,加过密的,即使被截获,我也不希望出现类似于艳照门的事件,尽管在码农的生活中可能无艳可照&#8230;
在 Linux 或 OSX, 我可以使用一个 <a href="http://huoxu.me/blog/2012/08/16/shi-yong-gnupg-dui-ri-zhi-jia-mi/"> GnuPG </a> 的工具对我想要对外共享的文件进行密码保护.</p>

<pre><code>安装 GnuPG
使用Gentoo. 

sudo emerge gpg


在Mac OSX 下可以使用 Homebrew:

brew install gpg
</code></pre>

<p>加密一个敏感文件</p>

<pre><code>gpg -c sensitive.txt
</code></pre>

<p>因为是对称加密, 它会提示:</p>

<pre><code>Enter passphrase:
Repeat passphrase: 
</code></pre>

<p>如果成功, 会生成一个sensitive.txt.gpg文件, 当然了, 它的内容是人类不可读的.</p>

<p>你可以随意分发传送这个文件..</p>

<p>接收方只需要对密文件:</p>

<pre><code>gpg sensitive.txt.gpg
</code></pre>

<p>当然了, 假设对方是知道你的对称密码的.</p>

<pre><code>gpg: CAST5 encrypted data
Enter passphrase: 
</code></pre>

<p>输入密码短语后, 它会还原成原文件 sensitive.txt.</p>

<p>Dropbox作为云端文件存储利器, 方便的同时, 可能也会带来安全隐患, 很有必要对你存储的文件做一层加密.</p>

<p>使用基于gpg的Dropbox 加密项目, 基本可以做到无忧.</p>

<p><a href="https://github.com/woodwardjd/lockbox/">https://github.com/woodwardjd/lockbox/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSON + UDP + DHT = Freedom ?]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/08/24/freedom/"/>
    <updated>2012-08-24T17:42:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/08/24/freedom</id>
    <content type="html"><![CDATA[<p>它的工作原理是发送和接收少量的JSON bit,通过UDP协议 使用有效的路由系统 基于<a href="http://en.wikipedia.org/wiki/Kademlia">Kademlia</a>.</p>

<p><strong>科普时间</strong></p>

<blockquote><p>Kademlia属于一种结构化的P2P网络,在Kademlia网络中,所有信息均以160比特SHA1散列哈希表条目形式加以存储,这些条目被分散地存储在各个节点上,从而以全网方式构成一张巨大的分布式哈希表</p></blockquote>

<p>和日渐成熟的<a href="http://en.wikipedia.org/wiki/Distributed_hash_table">分布式哈希表</a>.
TeleHash路由, 它就是基于一个通用的,ID或URL相关的SHA哈希散列.</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/9/98/DHT_en.svg/500px-DHT_en.svg.png"></img></p>

<p>比如官网给出的获取种子的实例:</p>

<pre><code>echo '{"+end":"3b6a6..."}' | nc -u telehash.org 42424
</code></pre>

<p>它将回应一个json 串:</p>

<pre><code>{"_ring":17904, ".see":[ "208.68.163.247:42424", "208.68.160.25:55137"], "_br":52, "_to":"173.19.99.143:63681" }
</code></pre>

<p>感兴趣的可以去瞅瞅 <a href="http://telehash.org/"> telehash </a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[珍惜身边的人]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/08/23/zhen-xi/"/>
    <updated>2012-08-23T17:59:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/08/23/zhen-xi</id>
    <content type="html"><![CDATA[<p>有一部电影, 有一个场景: 一个孩子在卫生间洗澡，水迷了眼,睁不开; 他扶着墙壁，大叫: &#8221; 妈妈,毛巾,毛巾.. &#8221;</p>

<p>许久,男孩儿呆在那里,继而瘫坐在一旁,他无声地哭了。</p>

<p>他的母亲不久前刚刚去世; 以前,他都是这样习惯性地呼唤妈妈的.</p>

<p>就像我每次回家后, 总会想起奶奶从前在的时候, 总会提前热好水, 做好饭菜, 备好毛毯&#8230; 生怕我长途坐车, 累着, 饿着&#8230;
每每想到此情此景, 而物是人非, 我眼泪就止不住止的流&#8230;  那是种被爱的习惯&#8230;  习惯了, 也就放不开了&#8230;</p>

<p>我们需要一个人,在自己心神疲惫的时候随叫随到,任凭自己发泄情绪而不会生气.</p>

<p>这样的一个人,不会很多. 一辈子只能遇上一位,或者终老也不会遇上.</p>

<p>七夕了, 珍惜身边的人, 时间很长, 时间也很短&#8230;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le.git for humans]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/08/23/le-dot-git-for-humans/"/>
    <updated>2012-08-23T12:16:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/08/23/le-dot-git-for-humans</id>
    <content type="html"><![CDATA[<p><strong>Let&#8217; git..
让git的工作流程变的更可读, 简单.</strong></p>

<pre><code>$ git switch &lt;branch&gt;
# Switches to branch. Stashes and restores unstaged changes.

$ git sync
# Syncronizes current branch. Auto-merge/rebase, un/stash.

$ git publish &lt;branch&gt;
# Publishes branch to remote server.

$ git unpublish &lt;branch&gt;
# Removes branch from remote server.

$ git harvest &lt;branch&gt;
# Auto-merge/rebase commits from given branch.

$ git sprout &lt;branch&gt;
# Sprout a new branch from the current branch.

$ git graft &lt;branch&gt;
# Merge unpublished branch into current branch, then remove it.

$ git branches
# Nice &amp; pretty list of branches + publication status.
</code></pre>

<p><strong>Installing Legit</strong></p>

<p><strong>To install the legit command:</strong></p>

<pre><code>$ pip install legit
</code></pre>

<p><strong>To enable the git aliases:</strong></p>

<pre><code>$ legit install
</code></pre>

<p><strong><em>Nice and simple — the way it should be.</em></strong></p>

<p>github : <a href="https://github.com/kennethreitz/legit"> legit </a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Gnupg 对日志加密]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/08/16/shi-yong-gnupg-dui-ri-zhi-jia-mi/"/>
    <updated>2012-08-16T18:22:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/08/16/shi-yong-gnupg-dui-ri-zhi-jia-mi</id>
    <content type="html"><![CDATA[<p><strong>关于加密:</strong></p>

<p>理论上你不应该为你的信息在储存和传送过程中的安全而担心. 然国内局域网环境恶劣,众所周知.何况还有伟大的GFW..</p>

<p><em>现代密码学的发展使得普通人也可以使用加密技术</em>  比如<a href="http://www.gnupg.org/">GnuPG</a> 就可以帮你在数据传输过程中签名和加密,而且是跨平台的.</p>

<p><a href="http://www.gnupg.org/">GnuPG</a> 采用 RSA 体系,这是一种非对称的加密方式.过程是:先生成一对密钥,私钥自己保存,而公钥可以公开到任意场景.数据发送方使用公钥加密的内容,只有你可以用私钥解开;你自己用私钥加密的内容,只有用你的公钥可以解开.so,你只需要公开你的公钥,对方就可以用你的公钥给你发送数据,这数据只有你可以解开;如果双方交换了各自的公钥,就可以实现双方相互之间的加密通讯了.</p>

<p><strong>使用:</strong></p>

<p>背景: 某项目的log数据, 机密且敏感.</p>

<p>于是设计使用gnupg 为之传输加密.</p>

<p>使用<a href="http://code.google.com/p/python-gnupg/" >python-gnupg</a> .</p>

<p>使用很简单:</p>

<pre><code>import gnupg
def encrypt_line(line):
    gpg = gnupg.GPG(gnupghome=GPG_HOME)
    encrypted_data = gpg.encrypt(line, '***@')
    encrypted_string = str(encrypted_data)
    print 'ok: ', encrypted_data.ok
    return encrypted_string
</code></pre>

<p>具体做法是, 使用具体机器名和邮箱作为sign, 生成一对公私钥. 私钥单独一台服务器保存..</p>

<p>python logging在代码里收集支付信息, 通过使用公钥加密, 丢给<a href="http://en.wikipedia.org/wiki/Syslog">syslog</a>, 转发至具体的日志server.</p>

<p>虽然流程繁琐, 但目前想来, 还算通用.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LLVM bitcode into Python..]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/08/10/llvm-bitcode-into-python-dot/"/>
    <updated>2012-08-10T14:46:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/08/10/llvm-bitcode-into-python-dot</id>
    <content type="html"><![CDATA[<p>传统的Python程序员屌丝,可能会使用ctypes直接调用由C编译出来的函数,所谓的调用c的动态链接库.好处是接口简洁,兼容绝大部分的C类型数据结构..收益也很明显,大多都是为了解决性能上的问题.</p>

<pre><code>import ctypes;
h = ctypes.CDLL('**.so')
</code></pre>

<p>再说说LLVM (Low Level Virtual Machine) 一个低级别的虚拟机.. 但和JVM等等传统意义上的虚拟机不一样的是, LLVM能够在编译期优化、链接优化、甚至在线编译优化.</p>

<p>LLVM严格说来是一个编译器架构体系. 怎么说呢? 编译器的开发者仅需开发一个可以把原始码转换成LLVM的bitcode的格式(frontend),而转换至机器语言的部分则由另一批开发人员开发(backend). 这样做的好处是使得程序语言可以很轻松的跨越各种平台(LLVM在各个平台所使用的bitcode是一样的).</p>

<p>然后, 我想介绍的是这么一个东东: <a href="https://github.com/dabeaz/bitey">Bitey </a></p>

<p>它可以把以上提到的两个概念衔接到一起&#8230; 它可以将LLVM的bitcode直接导入到Python中作为一个扩展模块.</p>

<p>开始前提是, 你开启了configure &#8211;enable-shared=yes编译选项. 和安装了<a href="http://www.llvmpy.org">link text</a>llvm-py python for llvm扩展.</p>

<p><strong>Ok, 首先, 我写了一个很简单C版本的伪随机数生成器.</strong></p>

<pre><code>//srands.c
#include &lt;stdio.h&gt;                                   
#include &lt;time.h&gt;

int srandom()
{
    int random;
    srand( (unsigned)time( NULL ) );
    random = rand();
    return random;
}
</code></pre>

<p>然后, 我通过clang 把它编译成LLVM bitcode:</p>

<pre><code>bash % clang -emit-llvm -c srands.c
</code></pre>

<p>这将会生成一个srands.o文件,它包含了LLVM bitcode. 现在,只需把它导入到Python:</p>

<pre><code>&gt;&gt;&gt; import bitey
&gt;&gt;&gt; import srands
&gt;&gt;&gt; srands.srandom()
5788877353
&gt;&gt;&gt;
</code></pre>

<p>没错,就是这样.bitey不使用C编译器,连接器,或动态装载器. 你不需要写包装函数,只需要正常的实现一个C程序,然后,编译,导入和完成.</p>

<p>bitey兼容大多数C数据类型,包括整数,浮点数,void,指针,数组和结构体.事实上因为它复用了ctypes的基础接口.</p>

<p>下面是一个稍微复杂一点的结构体数据类型的交互:</p>

<pre><code>/* point.c */
#include &lt;math.h&gt;

struct Point {
    double x;
    double y;
};

double distance(struct Point *p1, struct Point *p2) {
    return sqrt((p1-&gt;x - p2-&gt;x)*(p1-&gt;x - p2-&gt;x) +
                (p1-&gt;y - p2-&gt;y)*(p1-&gt;y - p2-&gt;y));
}
</code></pre>

<p>And then 运行:</p>

<pre><code>% clang -emit-llvm -c point.c
% python
&gt;&gt;&gt; import bitey
&gt;&gt;&gt; import point
&gt;&gt;&gt; p1 = point.Point(3,4)
&gt;&gt;&gt; p2 = point.Point(6,8)
&gt;&gt;&gt; point.distance(p1,p2)
5.0
&gt;&gt;&gt;
</code></pre>

<p>需要说明的是,LLVM的bitcode不编码结构域的名称.因此,Bitey需将它们分配给这样的索引元素变量:</p>

<pre><code>&gt;&gt;&gt; p1.e0         # (Returns the .x component)
3
&gt;&gt;&gt; p1.e1         # (Returns the .y component)
4
</code></pre>

<p>也可以使用LLVM &#8220;高级主题&#8221;中所说的预加载模块, 让你瞬间变身高富帅..</p>

<p>如果需要把两个LLVM的目标文件一起合并成一个单一的导入模块,使用llvm-ld命令:</p>

<pre><code>% llvm-ld point.o srands.o -b combined.o
% python
&gt;&gt;&gt; import bitey
&gt;&gt;&gt; import combined
&gt;&gt;&gt; combined.srandom()
5345345646
&gt;&gt;&gt; p1 = combined.Point(3,4)
&gt;&gt;&gt; p2 = combined.Point(6,8)
&gt;&gt;&gt; combined.distance(p1,p2)
5.0
&gt;&gt;&gt;
</code></pre>

<p>很多时候,我们写的C代码需要链接外部库.于是在导入之前可以采取特殊的方法来加载库.
比如:</p>

<pre><code># OS-X
% gcc -bundle -export_dynamic srands.c -o libsrands.so

# Linux
% gcc -shared srands.c -o libsrands.so
</code></pre>

<p>现在,假设有一些C代码要访问这个库:</p>

<pre><code>/* sample.c */
#include &lt;stdio.h&gt;
extern int srandom();

void print_srandom() {
    int n = 5;
    // 随机数生成,打印5次.
    while (n -- &gt;= 0) {
        printf("%d\n", srandom());
    }
}
</code></pre>

<p>你很希望它能正常执行, 但不幸的是, 它报错了&#8230;</p>

<pre><code>% clang -emit-llvm -c sample.c
% python
&gt;&gt;&gt; import bitey
&gt;&gt;&gt; import sample
LLVM ERROR: Program used external function 'srandom' which could not be resolved!
%
</code></pre>

<p>不怕不怕&#8230; 问题可以这样解决:</p>

<pre><code> % python
 &gt;&gt;&gt; import bitey
 &gt;&gt;&gt; bitey.load_library("./libsrands.so")
&lt;CDLL './libsrands.so', handle 13203afc60 at 10179d190&gt;
 &gt;&gt;&gt; import sample
 &gt;&gt;&gt; sample.print_srandom()
 354534534
 65645434
 5454535
 546456546645
 45345345
 &gt;&gt;&gt;
</code></pre>

<p>需要说明的是,Bitey不使用C编译器,连接器,动态加载程序,或者涉及子进程调用.它是完全独立的,粘合了llvm-py和ctypes的功能.</p>

<p>自动绑定</p>

<p>在以上例子中,它使用import bitey的方式来识别和加载模块.如果你想跳过这一步,让一切自动,可以创建一个bitey.pth文件,它包含了下面的声明:</p>

<pre><code>#bitey.pth
import bitey
</code></pre>

<p>现在,只需要把这个文件复制到Python的site-packages目录下.</p>

<p>That&#8217;s all..  : )</p>

<p>参考: <a href="https://github.com/dabeaz/bitey"> bitey on github </a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[怎么创建可靠的网络服务?]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/08/08/zen-yao-chuang-jian-ke-kao-de-wang-luo-fu-wu/"/>
    <updated>2012-08-08T18:53:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/08/08/zen-yao-chuang-jian-ke-kao-de-wang-luo-fu-wu</id>
    <content type="html"><![CDATA[<p>还记得若干年前的c10k问题,现今软硬件的不断更迭,开源社区的蓬勃壮大,各种问题,似乎已不是什么问题.
但还是萌生了一些想法,在此分享一些运营技巧,不限语言, 不限网站.</p>

<p>创建可扩展的和可靠的服务归结为以下:</p>

<p><strong>监视一切:</strong></p>

<pre><code>必须有一个清晰的画面在任何时间上发生了什么事.过去的表现如何,
重视日志,记录应用程序中的可觉察指标,并尽量将其可视化,可视化响应时间,pv,以及等等..
使用Google Analytics是不够的,你还需要更多强大的辅助工具.
</code></pre>

<p><strong>积极主动:</strong></p>

<pre><code>主动备份和尽早对未来负载做好规划预期,不要等到网站失去响应的时候才开始想到优化.
如果可以,度量关于你的系统可以处理多少更多的用户,这样就可以采取猜测预估,认为哪些策略可以适用.
</code></pre>

<p><strong>当崩溃发生时的通知:</strong></p>

<pre><code>使用诸如&lt;a href="http://pingdom.com/"&gt;PingDom&lt;/a&gt;类的服务
或者像&lt;a href="http://github.com/amix/crash_hound"&gt;crash_hound&lt;/a&gt;的开源库.
</code></pre>

<p><strong>你可以使用的工具</strong></p>

<p>我用了很多工具,没有必要重新造轮子,我强烈推荐他们.</p>

<p><strong>不要失去对任何事物的实时监控权</strong></p>

<p>我读到有关<a href="https://github.com/etsy/statsd/">statsd</a>和<a href="http://graphite.wikidot.com/">Graphite</a>, 和拜读了这篇文章<a href="http://instagram-engineering.tumblr.com/post/20541814340/keeping-instagram-up-with-over-a-million-new-users-in">Keeping Instagram up with over a million new users in twelve hours. </a></p>

<p>读完这篇文章后,我很兴奋,我花了一天时间去安装statsd+Graphite和运行。Graphite起步有点复杂,但收益很明显,我必须说,它改变了我的生活.这个设置可以让你实时跟踪,却没有任何性能损失（statsd使用非阻塞的UDP通讯）.我跟踪的平均响应时间,错误的数量,注册量,同步命令的平均响应时间等等,跨服务器和跨服务.</p>

<p>这是非常有用的,比如当你做了很多的部署,但你却可以很快地看到你的最新部署是否引入错误或性能问题.</p>

<p>下面是我的Graphite dashboards:</p>

<p><img src="http://amix.dk/uploads/statsd.png"></img></p>

<p><strong>监视性能,如果系统崩溃时能立刻得到通知</strong></p>

<p>Pingdom 是非常有用的一个服务,因为它可以在世界多个地点跟踪性能,当你的网站崩溃时,它可以短信通知你. 并且Pingdom也是公开的,可以让用户跟踪你的正常运行时间和性能（对用户而言,这是非常有用的服务）.</p>

<p>还有一些强大的工具,比如<a href="http://github.com/amix/crash_hound">crash_hound</a>,可以让你的程序得到通知. 例如:我收到一条短信,条件是,如果一个队列crash或它已经失去处理能力. 而我们的通知模块中,大部分都是安装使用不到10行代码的小脚本.</p>

<p>Pingdom的显页面的样子:</p>

<p><img src="http://amix.dk/uploads/pingdom.png"></img></p>

<p><strong>central logger 记录每一个错误</strong></p>

<p>我们有一个中央的日志处理系统,记录着每一个错误,并显示在一个中央位置,对应每一个错误,我们可以看到一个请求的上下文环境.这是一个非常必要的Web服务工具，因为它使你跟踪错误变的非常容易.</p>

<p>下面是我们的中央记录器看起来像:</p>

<p><img src="http://amix.dk/uploads/central_logger.png"></img></p>

<p>我相信有很多开源工具可以做到这一点（但我没有找到最适合我们的,所以我们自己实现了一套）.</p>

<p><strong>SQL monitor</strong></p>

<p>我们有一个SQL聚合查询,它记录着最耗时或最耗资源的查询记录.我们也有一个请求的记录,记录着同样的数据.</p>

<p>如果你想知道你的代码,哪一部分是值得的优化, 那么这两个工具必不可少.</p>

<p>我之前开源了一个工具<a href="http://amix.dk/blog/viewEntry/19359">request logger</a>（它使用非常简单,而且很容易hack.）</p>

<p>这里有一个截图:</p>

<p><img src="http://amix.dk/uploads/request_logger.jpg"></img></p>

<p><strong>监控服务器</strong></p>

<p>亚马逊AWS托管是一种特权，因为他们提供了很多伟大的监控工具（如CPU使用率和报警等,如果你的服务器可能使用超额的资源, 那么这种监控就很有必要）.</p>

<p>以及一些开源工具。在Plurk(一个类微博的网站)，我们使用<a href="http://www.cacti.net/">Cacti</a> 和 <a href="http://www.nagios.org/">Nagios</a>,这两个都是很复杂和强大的工具,值得你花时间去深入研究它, 因为它们可以给你以很cool的可视化图像形式显示正在运行的服务器和服务的状态.</p>

<p>下面是一些亚马逊的监测工具的截图:</p>

<p><img src="http://amix.dk/uploads/ec2.png"></img></p>

<p>我希望这些经验对你们有用.将来如:central logger or SQL monitor 这类有效的监控工具都将开源.</p>

<p>敬请关注,一如既往:happy hacking!</p>

<p>蹩脚译文出自: <a href="http://amix.dk/blog/post/19709#How-to-create-very-reliable-web-services">How to create very reliable web services </a>   Thanks amix.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个高效的Bresenham's 算法实现]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/08/08/%5B%3F%5D-ge-shuai-qi-de-bresenhams-suan-fa-shi-xian/"/>
    <updated>2012-08-08T15:26:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/08/08/[?]-ge-shuai-qi-de-bresenhams-suan-fa-shi-xian</id>
    <content type="html"><![CDATA[<p><strong>Bresenham算法原理解释是</strong></p>

<p><strong>　　对各行,各列像素中心先构造一组虚拟网格线,按直线从起点到终点的顺序计算直线各垂直网格线的交点,然后确定该列像素中与此交点最近的像素.
   并且可以采用增量计算,使得对于每一计算列列,只要检查一个误差项的符号,就可以确定该列所求的像素.</strong></p>

<p><strong>这里, 主要来介绍一种高效紧凑的算法实现.</strong></p>

<p>下面列出了四个C 程序的例子</p>

<p>具体的实现代码你也可以直接下载 <a href="http://free.pages.at/easyfilter/bresenham.c">bresenham.c</a></p>

<h1>Bresenham画线算法的一个简单的例子</h1>


<pre><code>void plotLine(int x0, int y0, int x1, int y1)
{
    int dx =  abs(x1-x0), sx = x0&lt;x1 ? 1 : -1;
    int dy = -abs(y1-y0), sy = y0&lt;y1 ? 1 : -1; 
    int err = dx+dy, e2; /* error value e_xy */

    for(;;){  /* loop */
      setPixel(x0,y0);
      if (x0==x1 &amp;&amp; y0==y1) break;
      e2 = 2*err;
      if (e2 &gt;= dy) { err += dy; x0 += sx; } /* e_xy+e_x &gt; 0 */
      if (e2 &lt;= dx) { err += dx; y0 += sy; } /* e_xy+e_y &lt; 0 */
    }
}
</code></pre>

<p><td><img src="http://free.pages.at/easyfilter/line.png" alt="Line"></td></tr></tr></p>

<h1>这是一个画圆的算法实现</h1>


<pre><code>void plotCircle(int xm, int ym, int r)
{
   int x = -r, y = 0, err = 2-2*r; /* II. Quadrant */ 
   do {
      setPixel(xm-x, ym+y); /*   I. Quadrant */
      setPixel(xm-y, ym-x); /*  II. Quadrant */
      setPixel(xm+x, ym-y); /* III. Quadrant */
      setPixel(xm+y, ym+x); /*  IV. Quadrant */
      r = err;
      if (r &lt;= y) err += ++y*2+1;           /* e_xy+e_y &lt; 0 */
      if (r &gt; x || err &gt; y) err += ++x*2+1; /* e_xy+e_x &gt; 0 or no 2nd y-step */
   } while (x &lt; 0);
}
</code></pre>

<p><td><img src="http://free.pages.at/easyfilter/circle.png" alt="Line"></td></tr></tr></p>

<h1>矩形,椭圆形.</h1>


<pre><code>void plotEllipseRect(int x0, int y0, int x1, int y1)
{
   int a = abs(x1-x0), b = abs(y1-y0), b1 = b&amp;1; /* values of diameter */
   long dx = 4*(1-a)*b*b, dy = 4*(b1+1)*a*a; /* error increment */
   long err = dx+dy+b1*a*a, e2; /* error of 1.step */

   if (x0 &gt; x1) { x0 = x1; x1 += a; } /* if called with swapped points */
   if (y0 &gt; y1) y0 = y1; /* .. exchange them */
   y0 += (b+1)/2; y1 = y0-b1;   /* starting pixel */
   a *= 8*a; b1 = 8*b*b;

   do {
       setPixel(x1, y0); /*   I. Quadrant */
       setPixel(x0, y0); /*  II. Quadrant */
       setPixel(x0, y1); /* III. Quadrant */
       setPixel(x1, y1); /*  IV. Quadrant */
       e2 = 2*err;
       if (e2 &lt;= dy) { y0++; y1--; err += dy += a; }  /* y step */ 
       if (e2 &gt;= dx || 2*err &gt; dy) { x0++; x1--; err += dx += b1; } /* x step */
   } while (x0 &lt;= x1);

   while (y0-y1 &lt; b) {  /* too early stop of flat ellipses a=1 */
       setPixel(x0-1, y0); /* -&gt; finish tip of ellipse */
       setPixel(x1+1, y0++); 
       setPixel(x0-1, y1);
       setPixel(x1+1, y1--); 
   }
}
</code></pre>

<p><td><img src="http://free.pages.at/easyfilter/ellipse.png" alt="Line"></td></tr></tr></p>

<h1>渐变的贝塞尔曲线<Bézier curve>.</h1>


<pre><code>void plotBasicBezier(int x0, int y0, int x1, int y1, int x2, int y2)
{                            
  int sx = x2-x1, sy = y2-y1;
  long xx = x0-x1, yy = y0-y1, xy;         /* relative values for checks */
  double dx, dy, err, cur = xx*sy-yy*sx;                    /* curvature */

  assert(xx*sx &lt;= 0 &amp;&amp; yy*sy &lt;= 0);  /* sign of gradient must not change */

  if (sx*(long)sx+sy*(long)sy &gt; xx*xx+yy*yy) { /* begin with longer part */ 
    x2 = x0; x0 = sx+x1; y2 = y0; y0 = sy+y1; cur = -cur;  /* swap P0 P2 */
  }  
  if (cur != 0) {                                    /* no straight line */
    xx += sx; xx *= sx = x0 &lt; x2 ? 1 : -1;           /* x step direction */
    yy += sy; yy *= sy = y0 &lt; y2 ? 1 : -1;           /* y step direction */
    xy = 2*xx*yy; xx *= xx; yy *= yy;          /* differences 2nd degree */
    if (cur*sx*sy &lt; 0) {                           /* negated curvature? */
      xx = -xx; yy = -yy; xy = -xy; cur = -cur;
    }
    dx = 4.0*sy*cur*(x1-x0)+xx-xy;             /* differences 1st degree */
    dy = 4.0*sx*cur*(y0-y1)+yy-xy;
    xx += xx; yy += yy; err = dx+dy+xy;                /* error 1st step */    
    do {                              
      setPixel(x0,y0);                                     /* plot curve */
      if (x0 == x2 &amp;&amp; y0 == y2) return;  /* last pixel -&gt; curve finished */
      y1 = 2*err &lt; dx;                  /* save value for test of y step */
      if (2*err &gt; dy) { x0 += sx; dx -= xy; err += dy += yy; } /* x step */
      if (    y1    ) { y0 += sy; dy -= xy; err += dx += xx; } /* y step */
    } while (dy &lt; 0 &amp;&amp; dx &gt; 0);   /* gradient negates -&gt; algorithm fails */
  }
  plotLine(x0,y0, x2,y2);                  /* plot remaining part to end */
}  
</code></pre>

<p><td><img src="http://free.pages.at/easyfilter/bezier.png" alt="Line"></td></tr></tr></p>

<h2>算法特点:</h2>


<blockquote><p>通用: 线,圆形,椭圆形,贝塞尔曲线等.</p>

<p>快速: 绘制复杂曲线非常快.</p>

<p>简单: 短而紧凑.</p>

<p>精确: 近似的精确曲线.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个很cool的项目: r³]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/07/27/%5B%3F%5D-ge-hen-coolde-xiang-mu-r3/"/>
    <updated>2012-07-27T18:28:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/07/27/[?]-ge-hen-coolde-xiang-mu-r3</id>
    <content type="html"><![CDATA[<p>r³ 是一个基于python的map reduce 引擎. 后端使用redis, 它的设计理念是:To be simple.</p>

<p>和任意一个MapReduce理论完备的项目[Haoop,Spark,Dpark..etc]一样.
它也分为: 输入流, mappers 和 reducers, 三个处理步骤.</p>

<p><img src="https://github.com/heynemann/r3" alt="image alt" /></p>

<h3>图显示不了了, 原因不明</h3>


<p>实践验证理论, Let&#8217;s do it.</p>

<p>先简单的通过pip安装:</p>

<pre><code>pip install r3
</code></pre>

<p>安装完之后, 会有三个命令:r3-app, r3-map,  r3-web.</p>

<p>看一个常见的Mapreduce场景计算: 对文档单词量的统计.</p>

<p>得有一个存储数据的地方,我先假设你有一个redis实例, 运行在 127.0.0.1:7778</p>

<p>运行:</p>

<pre><code>r3-app --redis-port=7778 --redis-pass=r3 -c config.py
</code></pre>

<p>上边运行的config.py, 作为一个接口配置, 它包含了输入和reduce的输出:</p>

<pre><code>INPUT_STREAMS = [
    'test.count_words_stream.CountWordsStream'
]

REDUCERS = [
    'test.count_words_reducer.CountWordsReducer'
]
</code></pre>

<p>Ok, 首先接触Input Stream.</p>

<p>一个典型的输入流场景,对文档样本进行计数的话,首先应该打开输入流处理器类的文件,读取文件中的行,然后返回的每一行给r3-app.</p>

<p><strong>input stream</strong></p>

<p>它可能是这样的:</p>

<pre><code>from os.path import abspath, dirname, join

class CountWordsStream:
    job_type = 'count-words'
    group_size = 1000

    def process(self, app, arguments):
        with open(abspath(join(dirname(__file__), 'chekhov.txt'))) as f:
            contents = f.readlines()

        return [line.lower() for line in contents]
</code></pre>

<p>指定一个job的类型: job_type = &#8216;count-words&#8217;
group_size = 1000,指定了一个输入流的大小.. 比如:1000, 那每个mapper分配到的处理大小就是1000行, 每1000行, 当做一次Input Stream做一次map.</p>

<p><strong>Running Mappers</strong></p>

<p>使用一个CountWordsMapper类来运行我们的映射.</p>

<pre><code>r3-map --redis-port=7778 --redis-pass=r3 --mapper-key=mapper-1 --mapper-class="test.count_words_mapper.CountWordsMapper"
</code></pre>

<p>它继承自r3 worker的Mapper类.</p>

<pre><code>from r3.worker.mapper import Mapper

class CountWordsMapper(Mapper):
    job_type = 'count-words'

    def map(self, lines):
        return list(self.split_words(lines))

    def split_words(self, lines):
        for line in lines:
            for word in line.split():
                yield word, 1
</code></pre>

<p><strong>Reducing</strong></p>

<p>在所有Input Stream都已经被Mapper合并处理后.. 这是一个连续的过程.. 我猜想, 应该和Dpark 类似, 也是lazy的. 需要数据时才会真正计算.</p>

<p>那么, Reduce 应该这样写了:</p>

<pre><code>from collections import defaultdict

class CountWordsReducer:
    job_type = 'count-words'

    def reduce(self, app, items):
        word_freq = defaultdict(int)
        for line in items:
            for word, frequency in line:
                word_freq[word] += frequency

        return word_freq
</code></pre>

<p>必须得指定job_type, 这可是reduce和map的血脉关系所在.. = =</p>

<p><strong>测试</strong></p>

<p>我们已经有一个R3应用程序运行在<a href="http://localhost:8888/count-words">http://localhost:8888</a>.</p>

<p>通过<a href="http://localhost:8888/count-words">http://localhost:8888/count-words</a> 访问我们刚刚的文档统计job.</p>

<p><strong>r³ 基于web的监控台 </strong></p>

<p><img src="https://github.com/heynemann/r3/raw/master/r3-web-4.jpg" alt="image alt" /></p>

<p><strong>状态</strong></p>

<p><img src="https://github.com/heynemann/r3/raw/master/r3-web-3.jpg" alt="image alt" /></p>

<p>项目地址: <code>[https://github.com/heynemann/r3][6]</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git tricks: stash]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/07/27/git-tricks-stash/"/>
    <updated>2012-07-27T17:33:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/07/27/git-tricks-stash</id>
    <content type="html"><![CDATA[<blockquote><p>Git tricks: stash</p>

<p>Git’s stash functionality is something
that you won’t need very often (in my
experience, ever) if you’re just
hacking away at something in private.
However, as soon as you introduce
other factors
- a boss, say - you’ll find you need to tweak your work-flow to make
yourself more interruptible.</p>

<p>Sometimes, something needs fixing
ASAP, and you have 260 build-breaking
lines an hour away from being
commit-worthy - you want to store that
code safely somewhere while you work
on the emergency. Without git stash,
you have two possibilities.</p></blockquote>

<ol>
<li><p>Create a temporary branch, commit
the broken code, and later abuse git
reset to undo the commit, Pure git,
very ugly, and it’s easy to bork
things with the git reset call.</p></li>
<li><p>Clone a new copy of the repository.
Much simpler, but not feasible for
larger repositories, and incredibly
hacky.</p></li>
</ol>


<p>Git stash introduces the idea of a temporary commit, orphaned in the sense that it does not belong to any branch, but can be restored later, on top of any other commit. The simplest usage:</p>

<pre><code>$ git stash
$ fix emergency
$ git commit -a -m "Emergency fix"
$ git stash pop
</code></pre>

<p>Of course, this being git, every feature has to be a little more powerful than that. The commit stored by stash is just like any other commit - it’s a patch which can be applied anywhere. Say you have a lot of branches flying around, and you accidentally start to make a change to the wrong one:</p>

<pre><code>$ git checkout widget-a
$ # add widget B
$ git stash -u
$ git checkout widget-b
$ git stash pop
</code></pre>

<p>The -u (equivalent to &#8211;include-untracked) put all untracked files in the stash as well, meaning that when you check out widget-b, you won’t have to re-compile your changes.</p>

<p>Or say you want to pull without committing, but some of your changes conflict:</p>

<pre><code>$ git stash &amp;&amp; git pull &amp;&amp; git stash pop
</code></pre>

<p>You can also drop and list stashes, and apply them without removing them from the stash stack.</p>

<p>Article from : [http://bytbox.net/blog/2012/07/git-stash.html][1]</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First blog with octopress]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/07/25/first-blog-with-octopress/"/>
    <updated>2012-07-25T16:24:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/07/25/first-blog-with-octopress</id>
    <content type="html"><![CDATA[<p>CU 和 GAE上的Blog 停止维护. 注册了新域名 <a href="http://huoxu.me">huoxu.me</a> 感谢关注.</p>

<p>尝试使用octopress 基于github pages 的方式写blog.</p>

<p>======================</p>

<blockquote><p>其中还是有很多个坑的. 但是上手很快.</p>

<blockquote><p>另 发现一个Octopress Markdown 语法高亮插件, 聊胜于无.</p></blockquote>

<h2><a href="https://github.com/tangledhelix/vim-octopress">vim-octopress</a></h2>

<p>参考
[1]:    <a href="http://en.wikipedia.org/wiki/Markdown">Markdown</a>
[2]:    <a href="http://octopress.org/docs/blogging/">octopress</a></p></blockquote>
]]></content>
  </entry>
  
</feed>
