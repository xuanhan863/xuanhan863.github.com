<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[huoxu.me]]></title>
  <link href="http://xuanhan863.github.com/atom.xml" rel="self"/>
  <link href="http://xuanhan863.github.com/"/>
  <updated>2012-08-08T15:56:58+08:00</updated>
  <id>http://xuanhan863.github.com/</id>
  <author>
    <name><![CDATA[{"name"=>&#8220;Tony.lee&#8221;, &#8220;twitter&#8221;=>&#8221;twitter.com/zzzzhe&#8221;}]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一个帅气的Bresenham's 算法实现]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/08/08/%5B%3F%5D-ge-shuai-qi-de-bresenhams-suan-fa-shi-xian/"/>
    <updated>2012-08-08T15:26:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/08/08/[?]-ge-shuai-qi-de-bresenhams-suan-fa-shi-xian</id>
    <content type="html"><![CDATA[<blockquote><p> 首先得先了解
 Bresenham算法原理是:
　　对各行,各列像素中心先构造一组虚拟网格线,按直线从起点到终点的
　　顺序计算直线各垂直网格线的交点,然后确定该列像素中与此交点最近
　　的像素. 并且可以采用增量计算,使得对于每一计算列列,只要检查一个误差项的符号,就可以确定该列所求的像素.</p></blockquote>

<h1>这里, 主要来介绍一种高效紧凑的算法实现.</h1>




<h2>下面列出了四个C 程序的例子<h2>

具体的实现代码你也可以直接下载 <a href="http://free.pages.at/easyfilter/bresenham.c">bresenham.c</a>


<h1>Bresenham画线算法的一个简单的例子</h1>
    
    void plotLine(int x0, int y0, int x1, int y1)
    {
        int dx =  abs(x1-x0), sx = x0<x1 ? 1 : -1;
        int dy = -abs(y1-y0), sy = y0<y1 ? 1 : -1; 
        int err = dx+dy, e2; /* error value e_xy */
 
        for(;;){  /* loop */
          setPixel(x0,y0);
          if (x0==x1 && y0==y1) break;
          e2 = 2*err;
          if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
          if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
        }
    }

<td><img src="http://free.pages.at/easyfilter/line.png" alt="Line"></td></tr></tr>

<h1>这是一个画圆的算法实现</h1>

    void plotCircle(int xm, int ym, int r)
    {
       int x = -r, y = 0, err = 2-2*r; /* II. Quadrant */ 
       do {
          setPixel(xm-x, ym+y); /*   I. Quadrant */
          setPixel(xm-y, ym-x); /*  II. Quadrant */
          setPixel(xm+x, ym-y); /* III. Quadrant */
          setPixel(xm+y, ym+x); /*  IV. Quadrant */
          r = err;
          if (r <= y) err += ++y*2+1;           /* e_xy+e_y < 0 */
          if (r > x || err > y) err += ++x*2+1; /* e_xy+e_x > 0 or no 2nd y-step */
       } while (x < 0);
    }

<td><img src="http://free.pages.at/easyfilter/circle.png" alt="Line"></td></tr></tr>

<h1>矩形,椭圆形.</h1>

    void plotEllipseRect(int x0, int y0, int x1, int y1)
    {
       int a = abs(x1-x0), b = abs(y1-y0), b1 = b&1; /* values of diameter */
       long dx = 4*(1-a)*b*b, dy = 4*(b1+1)*a*a; /* error increment */
       long err = dx+dy+b1*a*a, e2; /* error of 1.step */
    
       if (x0 > x1) { x0 = x1; x1 += a; } /* if called with swapped points */
       if (y0 > y1) y0 = y1; /* .. exchange them */
       y0 += (b+1)/2; y1 = y0-b1;   /* starting pixel */
       a *= 8*a; b1 = 8*b*b;
    
       do {
           setPixel(x1, y0); /*   I. Quadrant */
           setPixel(x0, y0); /*  II. Quadrant */
           setPixel(x0, y1); /* III. Quadrant */
           setPixel(x1, y1); /*  IV. Quadrant */
           e2 = 2*err;
           if (e2 <= dy) { y0++; y1--; err += dy += a; }  /* y step */ 
           if (e2 >= dx || 2*err > dy) { x0++; x1&#8211;; err += dx += b1; } /* x step */
       } while (x0 <= x1);
       
       while (y0-y1 < b) {  /* too early stop of flat ellipses a=1 */
           setPixel(x0-1, y0); /* -> finish tip of ellipse */
           setPixel(x1+1, y0++); 
           setPixel(x0-1, y1);
           setPixel(x1+1, y1&#8211;); 
       }
    }

<td><img src="http://free.pages.at/easyfilter/ellipse.png" alt="Line"></td></tr></tr>

<h1>渐变的贝塞尔曲线<Bézier curve>.</h1>

    void plotBasicBezier(int x0, int y0, int x1, int y1, int x2, int y2)
    {                            
      int sx = x2-x1, sy = y2-y1;
      long xx = x0-x1, yy = y0-y1, xy;         /* relative values for checks */
      double dx, dy, err, cur = xx*sy-yy*sx;                    /* curvature */
    
      assert(xx*sx <= 0 && yy*sy <= 0);  /* sign of gradient must not change */
    
      if (sx*(long)sx+sy*(long)sy > xx*xx+yy*yy) { /* begin with longer part */ 
        x2 = x0; x0 = sx+x1; y2 = y0; y0 = sy+y1; cur = -cur;  /* swap P0 P2 */
      }  
      if (cur != 0) {                                    /* no straight line */
        xx += sx; xx *= sx = x0 < x2 ? 1 : -1;           /* x step direction */
        yy += sy; yy *= sy = y0 < y2 ? 1 : -1;           /* y step direction */
        xy = 2*xx*yy; xx *= xx; yy *= yy;          /* differences 2nd degree */
        if (cur*sx*sy < 0) {                           /* negated curvature? */
          xx = -xx; yy = -yy; xy = -xy; cur = -cur;
        }
        dx = 4.0*sy*cur*(x1-x0)+xx-xy;             /* differences 1st degree */
        dy = 4.0*sx*cur*(y0-y1)+yy-xy;
        xx += xx; yy += yy; err = dx+dy+xy;                /* error 1st step */    
        do {                              
          setPixel(x0,y0);                                     /* plot curve */
          if (x0 == x2 && y0 == y2) return;  /* last pixel -> curve finished */
          y1 = 2*err < dx;                  /* save value for test of y step */
          if (2*err > dy) { x0 += sx; dx -= xy; err += dy += yy; } /* x step */
          if (    y1    ) { y0 += sy; dy -= xy; err += dx += xx; } /* y step */
        } while (dy < 0 && dx > 0);   /* gradient negates -> algorithm fails */
      }
      plotLine(x0,y0, x2,y2);                  /* plot remaining part to end */
    }  
 
<td><img src="http://free.pages.at/easyfilter/bezier.png" alt="Line"></td></tr></tr>


<h2>算法特点</h2>

    <h3>通用: 线,圆形,椭圆形,贝塞尔曲线等.</h3>
    <h3>快速: 绘制复杂曲线非常快.</h3>
    <h3>简单: 短而紧凑.</h3>
    <h3>精确: 近似的精确曲线</h3>

   

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个很cool的项目: r³]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/07/27/%5B%3F%5D-ge-hen-coolde-xiang-mu-r3/"/>
    <updated>2012-07-27T18:28:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/07/27/[?]-ge-hen-coolde-xiang-mu-r3</id>
    <content type="html"><![CDATA[<p>r³ 是一个基于python的map reduce 引擎. 后端使用redis, 它的设计理念是:To be simple.</p>

<p>和任意一个MapReduce理论完备的项目[Haoop,Spark,Dpark..etc]一样.
它也分为: 输入流, mappers 和 reducers, 三个处理步骤.</p>

<p><img src="https://github.com/heynemann/r3" alt="image alt" /></p>

<h3>图显示不了了, 原因不明</h3>


<p>实践验证理论, Let&#8217;s do it.</p>

<p>先简单的通过pip安装:</p>

<pre><code>pip install r3
</code></pre>

<p>安装完之后, 会有三个命令:r3-app, r3-map,  r3-web.</p>

<p>看一个常见的Mapreduce场景计算: 对文档单词量的统计.</p>

<p>得有一个存储数据的地方,我先假设你有一个redis实例, 运行在 127.0.0.1:7778</p>

<p>运行:</p>

<pre><code>r3-app --redis-port=7778 --redis-pass=r3 -c config.py
</code></pre>

<p>上边运行的config.py, 作为一个接口配置, 它包含了输入和reduce的输出:</p>

<pre><code>INPUT_STREAMS = [
    'test.count_words_stream.CountWordsStream'
]

REDUCERS = [
    'test.count_words_reducer.CountWordsReducer'
]
</code></pre>

<p>Ok, 首先接触Input Stream.</p>

<p>一个典型的输入流场景,对文档样本进行计数的话,首先应该打开输入流处理器类的文件,读取文件中的行,然后返回的每一行给r3-app.</p>

<p><strong>input stream</strong></p>

<p>它可能是这样的:</p>

<pre><code>from os.path import abspath, dirname, join

class CountWordsStream:
    job_type = 'count-words'
    group_size = 1000

    def process(self, app, arguments):
        with open(abspath(join(dirname(__file__), 'chekhov.txt'))) as f:
            contents = f.readlines()

        return [line.lower() for line in contents]
</code></pre>

<p>指定一个job的类型: job_type = &#8216;count-words&#8217;
group_size = 1000,指定了一个输入流的大小.. 比如:1000, 那每个mapper分配到的处理大小就是1000行, 每1000行, 当做一次Input Stream做一次map.</p>

<p><strong>Running Mappers</strong></p>

<p>使用一个CountWordsMapper类来运行我们的映射.</p>

<pre><code>r3-map --redis-port=7778 --redis-pass=r3 --mapper-key=mapper-1 --mapper-class="test.count_words_mapper.CountWordsMapper"
</code></pre>

<p>它继承自r3 worker的Mapper类.</p>

<pre><code>from r3.worker.mapper import Mapper

class CountWordsMapper(Mapper):
    job_type = 'count-words'

    def map(self, lines):
        return list(self.split_words(lines))

    def split_words(self, lines):
        for line in lines:
            for word in line.split():
                yield word, 1
</code></pre>

<p><strong>Reducing</strong></p>

<p>在所有Input Stream都已经被Mapper合并处理后.. 这是一个连续的过程.. 我猜想, 应该和Dpark 类似, 也是lazy的. 需要数据时才会真正计算.</p>

<p>那么, Reduce 应该这样写了:</p>

<pre><code>from collections import defaultdict

class CountWordsReducer:
    job_type = 'count-words'

    def reduce(self, app, items):
        word_freq = defaultdict(int)
        for line in items:
            for word, frequency in line:
                word_freq[word] += frequency

        return word_freq
</code></pre>

<p>必须得指定job_type, 这可是reduce和map的血脉关系所在.. = =</p>

<p><strong>测试</strong></p>

<p>我们已经有一个R3应用程序运行在<a href="http://localhost:8888/count-words">http://localhost:8888</a>.</p>

<p>通过<a href="http://localhost:8888/count-words">http://localhost:8888/count-words</a> 访问我们刚刚的文档统计job.</p>

<p><strong>r³ 基于web的监控台 </strong></p>

<p><img src="https://github.com/heynemann/r3/raw/master/r3-web-4.jpg" alt="image alt" /></p>

<p><strong>状态</strong></p>

<p><img src="https://github.com/heynemann/r3/raw/master/r3-web-3.jpg" alt="image alt" /></p>

<p>项目地址: <code>[https://github.com/heynemann/r3][6]</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git tricks: stash]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/07/27/git-tricks-stash/"/>
    <updated>2012-07-27T17:33:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/07/27/git-tricks-stash</id>
    <content type="html"><![CDATA[<blockquote><p>Git tricks: stash</p>

<p>Git’s stash functionality is something
that you won’t need very often (in my
experience, ever) if you’re just
hacking away at something in private.
However, as soon as you introduce
other factors
- a boss, say - you’ll find you need to tweak your work-flow to make
yourself more interruptible.</p>

<p>Sometimes, something needs fixing
ASAP, and you have 260 build-breaking
lines an hour away from being
commit-worthy - you want to store that
code safely somewhere while you work
on the emergency. Without git stash,
you have two possibilities.</p></blockquote>

<ol>
<li><p>Create a temporary branch, commit
the broken code, and later abuse git
reset to undo the commit, Pure git,
very ugly, and it’s easy to bork
things with the git reset call.</p></li>
<li><p>Clone a new copy of the repository.
Much simpler, but not feasible for
larger repositories, and incredibly
hacky.</p></li>
</ol>


<p>Git stash introduces the idea of a temporary commit, orphaned in the sense that it does not belong to any branch, but can be restored later, on top of any other commit. The simplest usage:</p>

<pre><code>$ git stash
$ fix emergency
$ git commit -a -m "Emergency fix"
$ git stash pop
</code></pre>

<p>Of course, this being git, every feature has to be a little more powerful than that. The commit stored by stash is just like any other commit - it’s a patch which can be applied anywhere. Say you have a lot of branches flying around, and you accidentally start to make a change to the wrong one:</p>

<pre><code>$ git checkout widget-a
$ # add widget B
$ git stash -u
$ git checkout widget-b
$ git stash pop
</code></pre>

<p>The -u (equivalent to &#8211;include-untracked) put all untracked files in the stash as well, meaning that when you check out widget-b, you won’t have to re-compile your changes.</p>

<p>Or say you want to pull without committing, but some of your changes conflict:</p>

<pre><code>$ git stash &amp;&amp; git pull &amp;&amp; git stash pop
</code></pre>

<p>You can also drop and list stashes, and apply them without removing them from the stash stack.</p>

<p>Article from : [http://bytbox.net/blog/2012/07/git-stash.html][1]</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First blog with octopress]]></title>
    <link href="http://xuanhan863.github.com/blog/2012/07/25/first-blog-with-octopress/"/>
    <updated>2012-07-25T16:24:00+08:00</updated>
    <id>http://xuanhan863.github.com/blog/2012/07/25/first-blog-with-octopress</id>
    <content type="html"><![CDATA[<h1>尝试使用octopress 基于github pages 的方式写blog</h1>

<blockquote><p>其中还是有很多个坑的. 但是上手很快.</p>

<blockquote><p>另 发现一个Octopress Markdown 语法高亮插件, 聊胜于无.</p></blockquote>

<h2><a href="https://github.com/tangledhelix/vim-octopress">vim-octopress</a></h2>

<p>参考
[1]:    <a href="http://en.wikipedia.org/wiki/Markdown">Markdown</a>
[2]:    <a href="http://octopress.org/docs/blogging/">octopress</a></p></blockquote>
]]></content>
  </entry>
  
</feed>
